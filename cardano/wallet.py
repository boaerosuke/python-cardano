'''
Implement wallet logic following the formal wallet specification.
'''

import operator
from collections import namedtuple, deque
from recordclass import recordclass

# Basic Model.

Tx = namedtuple('Tx', 'txid inputs outputs')
TxIn = namedtuple('TxIn', 'txid ix')
TxOut = namedtuple('TxOut', 'addr c')
# UTxO :: Map TxIn TxOut

def constraint_txins(txins, utxo):
    # More efficient than filter_ins
    return {txin: utxo[txin] for txin in txins if txin in utxo}

def exclude_txins_inplace(txins, utxo):
    # More efficient than filter_ins
    for txin in txins:
        utxo.pop(txin, None)
    return utxo

def balance(utxo):
    return sum(txout.c for txout in utxo.values())

def dom(utxo):
    return set(utxo.keys())

# Txs :: List(Tx)
def txins(txs):
    'set of inputs spent by transactions'
    result = set()
    for tx in txs:
        result |= tx.inputs
    return result

def ours_txouts(txs, addrs):
    'utxo generated by transactions which belongs to addresses.'
    return {TxIn(tx.txid, ix): txout for tx in txs for ix, txout in enumerate(tx.outputs) if txout.addr in addrs}

# Comment out current unused operations.
#def txouts(txs):
#    return {TxIn(tx.txid, ix): txout for tx in txs for ix, txout in enumerate(tx.outputs)}

def new_utxo(txs, addrs):
    'new utxo added by these transactions and owned by addrs.'
    return exclude_txins_inplace(txins(txs), ours_txouts(txs, addrs))

#def dependent_on(tx2, tx1):
#    'Check if tx2 is dependent on tx1'
#    return any(lambda txin: txin.txid == tx1.txid, tx2.inputs)

Checkpoint = recordclass('Checkpoint', 'utxo expected_utxo pending utxo_balance')
class Wallet(object):
    def __init__(self, addrs):
        self.addrs = set(addrs)
        self.checkpoints = deque([Checkpoint({}, {}, [], 0)], maxlen=2160)

    def change(self, txs):
        'return change UTxOs from transactions.'
        return ours_txouts(txs, self.addrs)

    def available_utxo(self):
        'available utxo'
        checkpoint = self.checkpoints[-1]
        utxo = checkpoint.utxo.copy()
        return exclude_txins_inplace(txins(checkpoint.pending), utxo)

    def total_utxo(self):
        'total utxo'
        return {**self.available_utxo(), **self.change(self.checkpoints[-1].pending)}

    def available_balance(self):
        checkpoint = self.checkpoints[-1]
        return checkpoint.utxo_balance - balance(constraint_txins(txins(checkpoint.pending), checkpoint.utxo))

    def total_balance(self):
        return self.available_balance() + balance(self.change(self.checkpoints[-1].pending))

    def apply_block(self, txs):
        checkpoint = self.checkpoints[-1]

        txouts_ = ours_txouts(txs, self.addrs)
        assert dom(txouts_) & dom(checkpoint.utxo) == set(), 'precondition doesn\'t meet'

        txins_ = txins(txs) & (dom(checkpoint.utxo) | dom(txouts_))
        self.apply_filtered_block(txins_, txouts_)

    def apply_filtered_block(self, txins_, txouts_):
        # add new utxo.
        checkpoint = self.checkpoints[-1]
        utxo = checkpoint.utxo.copy()
        utxo.update(txouts_)
        utxo_spent = constraint_txins(txins_, utxo)
        # remove spent utxo inplace.
        exclude_txins_inplace(txins_, utxo)
        utxo_balance = checkpoint.utxo_balance + balance(txouts_) - balance(utxo_spent)

        pending = filter(lambda tx: tx.inputs & txins_ == set, checkpoint.pending)

        new_utxo = exclude_txins_inplace(txins_, txouts_)
        expected_utxo = exclude_txins_inplace(dom(new_utxo), checkpoint.expected_utxo.copy())

        self.checkpoints.append(Checkpoint(utxo, expected_utxo, pending, utxo_balance))

    def new_pending(self, tx):
        assert tx.inputs.issubset(dom(self.available_utxo())), 'precondition doesn\'t meet.'
        self.checkpoints[-1].pending.append(tx)

    def rollback(self):
        assert self.checkpoints, 'no checkpoint, impossible.'
        if len(self.checkpoints) == 1:
            checkpoint = self.checkpoints[0]
            assert not checkpoint.pending and not checkpoint.utxo, 'impossible'
        else:
            old = self.checkpoints.pop()
            new = self.checkpoints[-1]
            new.pending += old.pending
            new.expected_utxo.update(old.expected_utxo)
            new.expected_utxo.update(exclude_txins_inplace(dom(new.utxo), old.utxo))

    # Invariants
    def invariant_3_4(self):
        checkpoint = self.checkpoints[-1]
        assert txins(checkpoint.pending).issubset(dom(checkpoint.utxo)), 'invariant 3.4 doesn\'t hold'

    def invariant_3_5(self):
        assert all(txout.addr in self.addrs for txout in self.checkpoints[-1].utxo.values()), 'invariant 3.5 doesn\'t hold'

    def invariant_3_6(self):
        assert dom(self.change(self.checkpoints[-1].pending)) & dom(self.available_utxo()) == set(), 'invariant 3.6 doesn\'t hold'

    def invariant_balance_cache(self):
        checkpoint = self.checkpoints[-1]
        assert checkpoint.utxo_balance == balance(checkpoint.utxo), 'balance cache broken.'
        assert self.available_balance() == balance(self.available_utxo()), 'available balance is wrong'
        assert self.total_balance() == balance(self.total_utxo()), 'total balance is wrong'

    def invariant_7_6(self):
        checkpoint = self.checkpoints[-1]
        assert dom(checkpoint.utxo) & dom(checkpoint.expected_utxo) == set(), 'invariant 7.6 doesn\'t hold'

    def invariant_7_7(self):
        assert all(txout.addr in self.addrs for txout in self.checkpoints[-1].expected_utxo.values()), 'invariant 7.7 doesn\'t hold'

    def invariant_7_8(self):
        checkpoint = self.checkpoints[-1]
        assert txins(checkpoint.pending).issubset(dom({**checkpoint.utxo, **checkpoint.expected_utxo})), 'invariant 7.8 doesn\'t hold'

    def check_invariants(self):
        invariants = [
            self.invariant_3_4,
            self.invariant_3_5,
            self.invariant_3_6,
            self.invariant_balance_cache,
            self.invariant_7_6,
            self.invariant_7_7,
            self.invariant_7_8,
        ]
        for inv in invariants:
            inv()

if __name__ == '__main__':
    # Test with local database.
    import cbor, binascii
    import random
    from .storage import Storage
    store = Storage('test_db', readonly=True)
    def random_addresses(threshold):
        addrs = set()
        for blk in store.blocks():
            for tx in blk.transactions():
                for txout in tx.outputs:
                    if random.random() < 0.1:
                        addrs.add(txout.addr)
                        if len(addrs) > threshold:
                            return addrs

    print('Collect random addresses to test.')
    w = Wallet(random_addresses(10000))
    print('Apply blocks')
    b = w.available_balance()
    for blk in store.blocks():
        txs = blk.transactions()
        if txs:
            w.apply_block(txs)
            w.check_invariants()
            n = w.available_balance()
            if n != b:
                b = n
                print('balance changed', b)
